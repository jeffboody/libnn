#version 450

layout (local_size_x=8, local_size_y=8, local_size_z=1) in;

shared float xmean_mb_work[64];

struct nn_dim_t
{
	uint count;
	uint height;
	uint width;
	uint depth;
};

layout(std430, set=0, binding=0) readonly buffer sb00
{
	uint  state_bs;
	float state_learning_rate;
	float state_momentum_decay;
	float state_batch_momentum;
	float state_l2_lambda;
	float state_clip_max_weight;
	float state_clip_max_bias;
	float state_clip_mu_inc;
	float state_clip_mu_dec;
	float state_clip_scale;
};

layout(std430, set=1, binding=0) readonly buffer sb10
{
	nn_dim_t dimX;
};

layout(std430, set=1, binding=1) readonly buffer sb11
{
	float X[];
};

layout(std430, set=1, binding=9) writeonly buffer sb19
{
	float Xmean_mb[];
};

layout(std430, set=1, binding=11) buffer sb111
{
	float Xmean_ra[];
};

layout(std430, set=3, binding=0) readonly buffer sb30
{
	uint idx_k;
};

float getX(uint n, uint i, uint j, uint k)
{
	uint sn = dimX.height*dimX.width*dimX.depth;
	uint sy = dimX.width*dimX.depth;
	uint sx = dimX.depth;
	return X[n*sn + i*sy + j*sx + k];
}

void set_Xmean_mb(uint n, float v)
{
	Xmean_mb[n] = v;
}

float get_Xmean_ra(uint n)
{
	return Xmean_ra[n];
}

void set_Xmean_ra(uint n, float v)
{
	Xmean_ra[n] = v;
}

void main()
{
	// dispatch required for each k
	// dispatch((k == 0) ? RAW : NONE, 1, 1, 1, 8, 8, 1)
	uint p   = gl_GlobalInvocationID.x;
	uint q   = gl_GlobalInvocationID.y;
	uint xh  = dimX.height;
	uint xw  = dimX.width;
	uint idx = 8*p + q;
	uint k   = idx_k;

	// initialize xmean_mb_work
	xmean_mb_work[idx] = 0.0;

	// compute xmean_mb_work
	uint m;
	uint i;
	uint j;
	for(m = 0; m < state_bs; ++m)
	{
		for(i = p; i < xh; i += 8)
		{
			for(j = q; j < xw; j += 8)
			{
				xmean_mb_work[idx] += getX(m, i, j, k);
			}
		}
	}

	// synchronize work
	memoryBarrierShared();
	barrier();

	// compute xmean_mb and xmean_ra
	if(idx == 0)
	{
		float xmean_mb = 0.0;

		uint  n;
		float M = float(state_bs)*float(xh)*float(xw);
		for(n = 0; n < 64; ++n)
		{
			xmean_mb += xmean_mb_work[n];
		}
		xmean_mb /= M;
		set_Xmean_mb(k, xmean_mb);

		// update running mean
		float xmean_ra;
		xmean_ra = get_Xmean_ra(k);
		xmean_ra = state_batch_momentum*xmean_ra +
		           (1.0 - state_batch_momentum)*xmean_mb;
		set_Xmean_ra(k, xmean_ra);
	}
}
