#version 450

layout (local_size_x=8, local_size_y=8, local_size_z=1) in;

shared float norm_w_work[64];
shared float norm_dl_dw_work[64];
shared float norm_b_work[64];
shared float norm_dl_db_work[64];

struct nn_dim_t
{
	uint count;
	uint height;
	uint width;
	uint depth;
};

layout(std430, set=0, binding=0) readonly buffer sb00
{
	uint  state_bs;
	float state_learning_rate;
	float state_momentum_decay;
	float state_batch_momentum;
	float state_l2_lambda;
	float state_clip_max;
	float state_clip_momentum;
};

layout(std430, set=0, binding=1) readonly buffer sb01
{
	uint param_disable_bias;
};

layout(std430, set=0, binding=4) readonly buffer sb04
{
	nn_dim_t dimW;
};

layout(std430, set=0, binding=5) readonly buffer sb05
{
	float W[];
};

layout(std430, set=0, binding=7) readonly buffer sb07
{
	float B[];
};

layout(std430, set=2, binding=0) buffer sb20
{
	float gc_gcw;
	float gc_gcb;
	float gc_norm_dl_dw_ra;
	float gc_norm_dl_db_ra;
};

layout(std430, set=2, binding=3) readonly buffer sb23
{
	nn_dim_t dim_dL_dW;
};

layout(std430, set=2, binding=4) readonly buffer sb24
{
	float dL_dW[];
};

layout(std430, set=2, binding=6) readonly buffer sb26
{
	float dL_dB[];
};

float getW(uint n, uint i, uint j, uint k)
{
	uint sn = dimW.height*dimW.width*dimW.depth;
	uint sy = dimW.width*dimW.depth;
	uint sx = dimW.depth;
	return W[n*sn + i*sy + j*sx + k];
}

float getB(uint n)
{
	return B[n];
}

float get_dL_dW(uint n, uint i, uint j, uint k)
{
	uint sn = dim_dL_dW.height*dim_dL_dW.width*dim_dL_dW.depth;
	uint sy = dim_dL_dW.width*dim_dL_dW.depth;
	uint sx = dim_dL_dW.depth;
	return dL_dW[n*sn + i*sy + j*sx + k];
}

float get_dL_dB(uint n)
{
	return dL_dB[n];
}

void main()
{
	// dispatch(RAW, 1, 1, 1, 8, 8, 1)
	uint  q   = gl_GlobalInvocationID.x;
	uint  p   = gl_GlobalInvocationID.y;
	uint  nc  = dimW.count;
	uint  xd  = dimW.depth;
	uint  idx = 8*p + q;
	float s   = 1.0/(float(state_bs));

	// initialize shared memory
	norm_w_work[idx]     = 0.0;
	norm_dl_dw_work[idx] = 0.0;
	norm_b_work[idx]     = 0.0;
	norm_dl_db_work[idx] = 0.0;

	// compute norm_w_work, norm_dl_dw_work,
	// norm_b_work and norm_dl_db_work
	uint  n;
	uint  k;
	float w;
	float b;
	float dl_dw;
	float dl_db;
	for(n = p; n < nc; n += 8)
	{
		// weights gradient
		for(k = q; k < xd; k += 8)
		{
			w                     = getW(n, 0, 0, k);
			dl_dw                 = s*get_dL_dW(n, 0, 0, k);
			norm_w_work[idx]     += w*w;
			norm_dl_dw_work[idx] += dl_dw*dl_dw;
		}

		// bias gradient
		if(param_disable_bias == 0)
		{
			b                     = getB(n);
			dl_db                 = s*get_dL_dB(n);
			norm_b_work[idx]     += b*b;
			norm_dl_db_work[idx] += dl_db*dl_db;
		}
	}

	// synchronize work
	memoryBarrierShared();
	barrier();

	// compute norm_w, norm_dl_dw, norm_b and norm_dl_db
	// finish gradient clipping
	if(idx == 0)
	{
		// sum work
		float norm_w     = 0.0;
		float norm_b     = 0.0;
		float norm_dl_dw = 0.0;
		float norm_dl_db = 0.0;
		for(n = 0; n < 64; ++n)
		{
			norm_w     += norm_w_work[n];
			norm_b     += norm_b_work[n];
			norm_dl_dw += norm_dl_dw_work[n];
			norm_dl_db += norm_dl_db_work[n];
		}

		// compute norms
		norm_w     = sqrt(norm_w);
		norm_b     = sqrt(norm_b);
		norm_dl_dw = sqrt(norm_dl_dw);
		norm_dl_db = sqrt(norm_dl_db);

		// compute running averages
		gc_norm_dl_dw_ra = state_clip_momentum*gc_norm_dl_dw_ra +
		                   (1.0 - state_clip_momentum)*norm_dl_dw;
		gc_norm_dl_db_ra = state_clip_momentum*gc_norm_dl_db_ra +
		                   (1.0 - state_clip_momentum)*norm_dl_db;

		// clamp norm
		if(state_clip_max > 0.0)
		{
			if(gc_norm_dl_dw_ra > state_clip_max)
			{
				gc_norm_dl_dw_ra = state_clip_max;
			}
			if(gc_norm_dl_db_ra > state_clip_max)
			{
				gc_norm_dl_db_ra = state_clip_max;
			}
		}

		// apply gradient clipping
		if(norm_dl_dw > gc_norm_dl_dw_ra)
		{
			gc_gcw = gc_norm_dl_dw_ra/norm_dl_dw;
		}
		if(norm_dl_db > gc_norm_dl_db_ra)
		{
			gc_gcb = gc_norm_dl_db_ra/norm_dl_db;
		}
	}
}
