#version 450

layout (local_size_x=8, local_size_y=8, local_size_z=1) in;

shared float loss_work[64];

struct nn_dim_t
{
	uint count;
	uint height;
	uint width;
	uint depth;
};

layout(std430, set=0, binding=0) readonly buffer sb00
{
	uint  state_bs;
	float state_adam_alpha;
	float state_adam_beta1;
	float state_adam_beta2;
	float state_adam_beta1t;
	float state_adam_beta2t;
	float state_adam_lambda;
	float state_adam_nu;
	float state_bn_momentum;
	float state_gan_blend_factor;
	float state_gan_blend_scalar;
	float state_gan_blend_min;
	float state_gan_blend_max;
};

layout(std430, set=0, binding=1) readonly buffer sb01
{
	nn_dim_t dimY;
};

layout(std430, set=0, binding=2) readonly buffer sb02
{
	float Y[];
};

layout(std430, set=0, binding=3) readonly buffer sb03
{
	nn_dim_t dimYt;
};

layout(std430, set=0, binding=4) readonly buffer sb04
{
	float Yt[];
};

layout(std430, set=0, binding=7) writeonly buffer sb07
{
	float loss;
};

float getY(uint n, uint i, uint j, uint k)
{
	uint sn = dimY.height*dimY.width*dimY.depth;
	uint sy = dimY.width*dimY.depth;
	uint sx = dimY.depth;
	return Y[n*sn + i*sy + j*sx + k];
}

float getYt(uint n, uint i, uint j, uint k)
{
	uint sn = dimYt.height*dimYt.width*dimYt.depth;
	uint sy = dimYt.width*dimYt.depth;
	uint sx = dimYt.depth;
	return Yt[n*sn + i*sy + j*sx + k];
}

float loss_mae(uint m, uint i, uint j, uint k)
{
	float y  = getY(m, i, j, k);
	float yt = getYt(m, i, j, k);
	float dy = y - yt;
	return abs(dy);
}

void main()
{
	// dispatch(RAW, 1, 1, 1, 8, 8, 1)
	uint p   = gl_GlobalInvocationID.x;
	uint q   = gl_GlobalInvocationID.y;
	uint yh  = dimY.height;
	uint yw  = dimY.width;
	uint yd  = dimY.depth;
	uint idx = 8*p + q;

	loss_work[idx] = 0.0;

	// compute working loss
	uint m;
	uint i;
	uint j;
	uint k;
	for(m = 0; m < state_bs; ++m)
	{
		for(i = p; i < yh; i += 8)
		{
			for(j = q; j < yw; j += 8)
			{
				for(k = 0; k < yd; ++k)
				{
					loss_work[idx] += loss_mae(m, i, j, k);
				}
			}
		}
	}
	memoryBarrierShared();
	barrier();

	// compute final loss
	if(idx == 0)
	{
		float sum = 0.0;
		float M   = float(state_bs*yh*yw*yd);

		uint n;
		for(n = 0; n < 64; ++n)
		{
			sum += loss_work[n];
		}

		loss = sum/M;
	}
}
