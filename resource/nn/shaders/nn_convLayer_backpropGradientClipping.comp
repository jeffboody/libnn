#version 450

layout (local_size_x=4, local_size_y=4, local_size_z=4) in;

shared float norm_w_work[64];
shared float norm_dl_dw_work[64];
shared float norm_b_work[64];
shared float norm_dl_db_work[64];

struct nn_dim_t
{
	uint count;
	uint height;
	uint width;
	uint depth;
};

layout(std430, set=0, binding=0) readonly buffer sb00
{
	uint  state_bs;
	float state_learning_rate;
	float state_momentum_decay;
	float state_batch_momentum;
	float state_l2_lambda;
	float state_clip_max_weight;
	float state_clip_max_bias;
	float state_clip_mu_inc;
	float state_clip_mu_dec;
	float state_clip_scale;
};

layout(std430, set=0, binding=1) readonly buffer sb01
{
	uint param_disable_bias;
	uint param_stride;
};

layout(std430, set=0, binding=4) readonly buffer sb04
{
	nn_dim_t dimW;
};

layout(std430, set=0, binding=5) readonly buffer sb05
{
	float W[];
};

layout(std430, set=0, binding=7) readonly buffer sb07
{
	float B[];
};

layout(std430, set=2, binding=0) buffer sb20
{
	float gc_gcw;
	float gc_gcb;
	float gc_norm_w;
	float gc_norm_b;
	float gc_norm_dl_dw;
	float gc_norm_dl_db;
	float gc_norm_dl_dw_ra;
	float gc_norm_dl_db_ra;
};

layout(std430, set=2, binding=3) readonly buffer sb23
{
	nn_dim_t dim_dL_dW;
};

layout(std430, set=2, binding=4) readonly buffer sb24
{
	float dL_dW[];
};

layout(std430, set=2, binding=6) readonly buffer sb26
{
	float dL_dB[];
};

float getW(uint n, uint i, uint j, uint k)
{
	uint sn = dimW.height*dimW.width*dimW.depth;
	uint sy = dimW.width*dimW.depth;
	uint sx = dimW.depth;
	return W[n*sn + i*sy + j*sx + k];
}

float getB(uint n)
{
	return B[n];
}

float get_dL_dW(uint n, uint i, uint j, uint k)
{
	uint sn = dim_dL_dW.height*dim_dL_dW.width*dim_dL_dW.depth;
	uint sy = dim_dL_dW.width*dim_dL_dW.depth;
	uint sx = dim_dL_dW.depth;
	return dL_dW[n*sn + i*sy + j*sx + k];
}

float get_dL_dB(uint n)
{
	return dL_dB[n];
}

uint umod(uint x, uint y)
{
	return uint(mod(int(x), int(y)));
}

void main()
{
	// dispatch(RAW, 1, 1, 1, 4, 4, 4)
	uint  q   = gl_GlobalInvocationID.x;
	uint  p   = gl_GlobalInvocationID.y;
	uint  r   = gl_GlobalInvocationID.z;
	uint  fc  = dimW.count;
	uint  fh  = dimW.height;
	uint  fw  = dimW.width;
	uint  xd  = dimW.depth;
	uint  idx = 16*p + 4*q + r;
	float s   = 1.0/(float(state_bs));

	// initialize shared memory
	norm_w_work[idx]     = 0.0;
	norm_dl_dw_work[idx] = 0.0;
	norm_b_work[idx]     = 0.0;
	norm_dl_db_work[idx] = 0.0;

	// compute norm_w_work, norm_dl_dw_work
	uint  f;
	uint  fi;
	uint  fj;
	uint  k;
	uint  n;
	float w;
	float b;
	float dl_dw;
	float dl_db;
	for(f = p; f < fc; f += 4)
	{
		// weights gradient
		for(fi = q; fi < fh; fi += 4)
		{
			for(n = r; n < fw*xd; n += 4)
			{
				fj                    = n/4;
				k                     = umod(n, 4);
				w                     = getW(f, fi, fj, k);
				dl_dw                 = s*get_dL_dW(f, fi, fj, k);
				norm_w_work[idx]     += w*w;
				norm_dl_dw_work[idx] += dl_dw*dl_dw;
			}
		}
	}

	// compute norm_b_work, norm_dl_db_work
	if((param_disable_bias == 0) && (q == 0) && (r == 0))
	{
		// bias gradient
		for(f = p; f < fc; f += 4)
		{
			b                     = getB(f);
			dl_db                 = s*get_dL_dB(f);
			norm_b_work[idx]     += b*b;
			norm_dl_db_work[idx] += dl_db*dl_db;
		}
	}

	// synchronize work
	memoryBarrierShared();
	barrier();

	// compute norm_w, norm_dl_dw, norm_b and norm_dl_db
	// finish gradient clipping
	if(idx == 0)
	{
		// sum work
		float norm_w     = 0.0;
		float norm_b     = 0.0;
		float norm_dl_dw = 0.0;
		float norm_dl_db = 0.0;
		for(n = 0; n < 64; ++n)
		{
			norm_w     += norm_w_work[n];
			norm_b     += norm_b_work[n];
			norm_dl_dw += norm_dl_dw_work[n];
			norm_dl_db += norm_dl_db_work[n];
		}

		// compute norms
		norm_w     = state_clip_scale*sqrt(norm_w);
		norm_b     = state_clip_scale*sqrt(norm_b);
		norm_dl_dw = state_clip_scale*sqrt(norm_dl_dw);
		norm_dl_db = state_clip_scale*sqrt(norm_dl_db);

		// save norm for logging
		gc_norm_w     = norm_w;
		gc_norm_b     = norm_b;
		gc_norm_dl_dw = norm_dl_dw;
		gc_norm_dl_db = norm_dl_db;

		// determine clip momentum
		float clip_mu;
		if(norm_dl_dw > gc_norm_dl_dw_ra)
		{
			clip_mu = state_clip_mu_inc;
		}
		else
		{
			clip_mu = state_clip_mu_dec;
		}

		// clamp norm_dl_dw
		if(state_clip_max_weight > 0.0)
		{
			if(norm_dl_dw > state_clip_max_weight)
			{
				norm_dl_dw = state_clip_max_weight;
			}
		}

		// compute running averages for norm_dl_dw
		gc_norm_dl_dw_ra = clip_mu*gc_norm_dl_dw_ra +
		                   (1.0 - clip_mu)*norm_dl_dw;

		// determine clip momentum
		if(norm_dl_db > gc_norm_dl_db_ra)
		{
			clip_mu = state_clip_mu_inc;
		}
		else
		{
			clip_mu = state_clip_mu_dec;
		}

		// clamp norm_dl_db
		if(state_clip_max_bias > 0.0)
		{
			if(norm_dl_db > state_clip_max_bias)
			{
				norm_dl_db = state_clip_max_bias;
			}
		}

		// compute running averages for norm_dl_db
		gc_norm_dl_db_ra = clip_mu*gc_norm_dl_db_ra +
		                   (1.0 - clip_mu)*norm_dl_db;

		// apply gradient clipping
		if(norm_dl_dw > gc_norm_dl_dw_ra)
		{
			gc_gcw = gc_norm_dl_dw_ra/norm_dl_dw;
		}
		if(norm_dl_db > gc_norm_dl_db_ra)
		{
			gc_gcb = gc_norm_dl_db_ra/norm_dl_db;
		}
	}
}
